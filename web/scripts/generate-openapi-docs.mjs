import { readFileSync, writeFileSync, readdirSync, existsSync, mkdirSync, rmSync, statSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, resolve, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Method order for display
const methodOrder = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];

// Special cases for title capitalization
const titleOverrides = {
  'llm': 'LLM',
  'api': 'API',
};

function capitalize(str) {
  if (titleOverrides[str.toLowerCase()]) {
    return titleOverrides[str.toLowerCase()];
  }
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function getSubPath(fullPath, resource) {
  const match = fullPath.match(new RegExp(`^/api/v1/${resource}(?:/(.+))?$`));
  return match ? match[1] || null : null;
}

function subPathToSlug(subPath) {
  if (!subPath) return 'index';
  return subPath
    .replace(/\{([^}]+)\}/g, '$1')
    .replace(/\//g, '-');
}

// Get a clean title from operations - use summaries
function getTitleFromOperations(operations, subPath, resource) {
  // For index pages (root of resource), use resource name
  if (!subPath) {
    return capitalize(resource);
  }

  // For sub-pages, combine operation summaries intelligently
  // e.g., "Get schema", "Update schema", "Delete schema" -> "Schema Details" or first summary
  const summaries = operations
    .map(op => op.operation?.summary)
    .filter(Boolean);

  if (summaries.length === 1) {
    return summaries[0];
  }

  // Multiple operations - find common noun or use descriptive title
  // "Get schema", "Update schema", "Delete schema" -> use the noun
  const firstSummary = summaries[0] || '';
  const words = firstSummary.split(' ');
  if (words.length >= 2) {
    // Use the noun part: "Get schema" -> "Schema"
    const noun = words.slice(1).join(' ');
    return capitalize(noun);
  }

  return firstSummary || `${capitalize(resource)} Operations`;
}

function generateMdxContent(operations, title, description) {
  const opsArray = operations.map(op => ({
    path: op.path,
    method: op.method.toLowerCase(),
  }));

  // Build TOC entries using operation summaries
  const tocEntries = operations.map(op => {
    const opTitle = op.operation?.summary || `${op.method} ${op.path}`;
    const opId = `${op.method.toLowerCase()}-${op.path.replace(/^\/api\/v1\//, '').replace(/[^a-z0-9]+/gi, '-').replace(/^-|-$/g, '')}`;
    return {
      depth: 2,
      title: opTitle,
      url: `#${opId}`,
    };
  });

  const headings = operations.map(op => {
    const opTitle = op.operation?.summary || `${op.method} ${op.path}`;
    const opId = `${op.method.toLowerCase()}-${op.path.replace(/^\/api\/v1\//, '').replace(/[^a-z0-9]+/gi, '-').replace(/^-|-$/g, '')}`;
    return {
      content: opTitle,
      id: opId,
    };
  });

  const contents = operations.map(op => {
    const opId = `${op.method.toLowerCase()}-${op.path.replace(/^\/api\/v1\//, '').replace(/[^a-z0-9]+/gi, '-').replace(/^-|-$/g, '')}`;
    return {
      content: op.operation?.description || op.operation?.summary || '',
      heading: opId,
    };
  });

  return `---
title: "${title}"
description: "${description.replace(/"/g, '\\"')}"
full: true
_openapi:
  toc:
${tocEntries.map(t => `    - depth: ${t.depth}
      title: "${t.title.replace(/"/g, '\\"')}"
      url: '${t.url}'`).join('\n')}
  structuredData:
    headings:
${headings.map(h => `      - content: "${h.content.replace(/"/g, '\\"')}"
        id: ${h.id}`).join('\n')}
    contents:
${contents.map(c => `      - content: "${c.content.replace(/"/g, '\\"')}"
        heading: ${c.heading}`).join('\n')}
---

{/* This file was generated by Fumadocs. Do not edit this file directly. */}

<APIPage document={"./openapi.json"} webhooks={[]} operations={${JSON.stringify(opsArray)}} showTitle={false} />
`;
}

async function main() {
  const outputDir = resolve(__dirname, '../content/docs/api-reference');
  const openapiPath = resolve(__dirname, '../openapi.json');

  // Load OpenAPI spec
  const openapi = JSON.parse(readFileSync(openapiPath, 'utf-8'));

  // Clean up old generated files and folders (except index.mdx and meta.json)
  const existingItems = readdirSync(outputDir);
  for (const item of existingItems) {
    if (item === 'index.mdx') continue;

    const itemPath = join(outputDir, item);
    try {
      const stat = statSync(itemPath);
      if (stat.isDirectory()) {
        rmSync(itemPath, { recursive: true });
        console.log(`Removed directory: ${item}`);
      } else if (item.endsWith('.mdx')) {
        rmSync(itemPath);
        console.log(`Removed file: ${item}`);
      }
    } catch (e) {
      // Ignore errors
    }
  }

  // Group operations by resource (first path segment after /api/v1/)
  const resourceGroups = new Map();

  for (const [path, methods] of Object.entries(openapi.paths)) {
    const resourceMatch = path.match(/^\/api\/v1\/([^/]+)/);
    if (!resourceMatch) continue;

    const resource = resourceMatch[1];

    for (const [method, operation] of Object.entries(methods)) {
      if (!['get', 'post', 'put', 'patch', 'delete'].includes(method)) continue;

      if (!resourceGroups.has(resource)) {
        resourceGroups.set(resource, new Map());
      }

      const subPath = getSubPath(path, resource);
      const subPathKey = subPath || '__root__';

      if (!resourceGroups.get(resource).has(subPathKey)) {
        resourceGroups.get(resource).set(subPathKey, []);
      }

      resourceGroups.get(resource).get(subPathKey).push({
        method: method.toUpperCase(),
        path,
        operation,
        subPath,
      });
    }
  }

  // Sort operations within each subpath by method order
  for (const [resource, subPaths] of resourceGroups) {
    for (const [subPath, ops] of subPaths) {
      ops.sort((a, b) => methodOrder.indexOf(a.method) - methodOrder.indexOf(b.method));
    }
  }

  // Generate structure
  const topLevelItems = [];

  for (const [resource, subPaths] of resourceGroups) {
    const subPathKeys = Array.from(subPaths.keys());
    const hasSubPaths = subPathKeys.length > 1 || (subPathKeys.length === 1 && subPathKeys[0] !== '__root__');

    if (hasSubPaths) {
      // Create a folder for this resource
      const resourceDir = join(outputDir, resource);
      if (!existsSync(resourceDir)) {
        mkdirSync(resourceDir, { recursive: true });
      }

      const subPages = [];

      for (const [subPathKey, operations] of subPaths) {
        const subPath = subPathKey === '__root__' ? null : subPathKey;
        const slug = subPathToSlug(subPath);

        // Use operation summaries to build nice titles
        const title = getTitleFromOperations(operations, subPath, resource);
        const description = operations[0]?.operation?.description ||
                           operations[0]?.operation?.summary ||
                           `${capitalize(resource)} operations`;

        const mdxContent = generateMdxContent(operations, title, description);
        const filePath = join(resourceDir, `${slug}.mdx`);
        writeFileSync(filePath, mdxContent);

        subPages.push({ slug, title, subPath });
        console.log(`Generated: ${resource}/${slug}.mdx -> "${title}"`);
      }

      // Sort subpages: index first, then alphabetically by slug
      subPages.sort((a, b) => {
        if (a.slug === 'index') return -1;
        if (b.slug === 'index') return 1;
        return a.slug.localeCompare(b.slug);
      });

      // Generate meta.json for this folder with titles
      const folderMeta = {
        title: capitalize(resource),
        pages: subPages.map(p => p.slug === 'index' ? 'index' : p.slug),
      };
      writeFileSync(join(resourceDir, 'meta.json'), JSON.stringify(folderMeta, null, 2) + '\n');

      topLevelItems.push(resource);

    } else {
      // Single endpoint - create a file at top level
      const operations = subPaths.get('__root__') || subPaths.values().next().value;
      const title = capitalize(resource);
      const description = operations[0]?.operation?.description ||
                         operations[0]?.operation?.summary ||
                         `${title} endpoint`;

      const mdxContent = generateMdxContent(operations, title, description);
      const filePath = join(outputDir, `${resource}.mdx`);
      writeFileSync(filePath, mdxContent);

      topLevelItems.push(resource);
      console.log(`Generated: ${resource}.mdx -> "${title}"`);
    }
  }

  // Sort top-level items alphabetically
  topLevelItems.sort();

  // Generate main meta.json
  const metaJson = {
    title: 'API Reference',
    pages: topLevelItems,
  };

  writeFileSync(
    join(outputDir, 'meta.json'),
    JSON.stringify(metaJson, null, 2) + '\n'
  );

  console.log(`\nGenerated meta.json with ${topLevelItems.length} top-level items`);
  console.log('Resources:', topLevelItems.join(', '));
}

main().catch(console.error);
