# Build workflow for refyne-api
# - On version tags (v*): Create a release with clean semver
# - On main branch: Create a pre-release snapshot with dev version
#
# Note: This workflow does NOT run on main branch pushes if the commit is also tagged.
# Tags take precedence - the tag-triggered run will create the release.

name: Build Release

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      snapshot_retention:
        description: "Number of snapshot releases to keep"
        required: false
        default: "5"
        type: string
      use_cache:
        description: "Use Go build cache (disable if you suspect cache issues)"
        required: false
        default: true
        type: boolean

# Cancel in-progress runs for the same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: stable
  SNAPSHOT_RETENTION: ${{ inputs.snapshot_retention || '5' }}

jobs:
  prepare:
    name: Prepare
    if: false  # Temporarily disabled during active development
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_tag: ${{ steps.version.outputs.version_tag }}
      is_release: ${{ steps.version.outputs.is_release }}
      should_skip: ${{ steps.version.outputs.should_skip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          SHOULD_SKIP=false

          # Check if this is a release (tag push)
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            IS_RELEASE=true
            # Strip 'v' prefix from tag: v1.2.3 -> 1.2.3
            VERSION="${GITHUB_REF_NAME#v}"
            VERSION_TAG="${GITHUB_REF_NAME}"
          else
            IS_RELEASE=false

            # For main branch builds, check if this commit already has a release tag
            # If so, skip this build as the tag-triggered workflow will handle it
            if [[ "${{ github.ref }}" == refs/heads/main ]]; then
              EXISTING_TAG=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1 || true)
              if [[ -n "$EXISTING_TAG" ]]; then
                echo "Commit already has release tag: ${EXISTING_TAG}"
                echo "Skipping main branch build - tag workflow will handle this"
                SHOULD_SKIP=true
              fi
            fi

            # Snapshot version format: {major}.{minor}.{next_patch}-dev.{commits}+{hash}
            if git describe --tags --always --long 2>/dev/null | grep -q '^v'; then
              DESCRIBE=$(git describe --tags --always --long 2>/dev/null)
              # Parse: vMAJOR.MINOR.PATCH-COMMITS-gHASH
              if [[ $DESCRIBE =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)-([0-9]+)-g([a-f0-9]+)$ ]]; then
                MAJOR=${BASH_REMATCH[1]}
                MINOR=${BASH_REMATCH[2]}
                PATCH=${BASH_REMATCH[3]}
                COMMITS=${BASH_REMATCH[4]}
                HASH=${BASH_REMATCH[5]}
                # Increment patch for dev version
                NEXT_PATCH=$((PATCH + 1))
                VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}+${HASH}"
                VERSION_TAG="v${MAJOR}.${MINOR}.${NEXT_PATCH}-dev.${COMMITS}"
              else
                # Fallback if pattern doesn't match
                SHORT_SHA=$(git rev-parse --short=7 HEAD)
                VERSION="0.0.1-dev.0+${SHORT_SHA}"
                VERSION_TAG="v0.0.1-dev.0-${SHORT_SHA}"
              fi
            else
              # No tags: initial dev version based on commit count
              COMMITS=$(git rev-list --count HEAD)
              SHORT_SHA=$(git rev-parse --short=7 HEAD)
              VERSION="0.0.1-dev.${COMMITS}+${SHORT_SHA}"
              VERSION_TAG="v0.0.1-dev.${COMMITS}"
            fi
          fi

          echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "Should skip: ${SHOULD_SKIP}"
          echo "Is release: ${IS_RELEASE}"
          echo "Version: ${VERSION}"
          echo "Version tag: ${VERSION_TAG}"

  build-api:
    name: Build API (${{ matrix.goos }}/${{ matrix.goarch }})
    runs-on: ubuntu-latest
    needs: prepare
    if: false  # Temporarily disabled during active development
    strategy:
      fail-fast: false
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: api/go.sum

      - name: Cache Go build
        if: inputs.use_cache != false
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-${{ matrix.goos }}-${{ matrix.goarch }}-go-${{ hashFiles('api/go.sum') }}-${{ github.run_number }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.goos }}-${{ matrix.goarch }}-go-${{ hashFiles('api/go.sum') }}-
            ${{ runner.os }}-${{ matrix.goos }}-${{ matrix.goarch }}-go-

      - name: Run tests
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        run: go test -v -race -timeout 120s ./...
        working-directory: api

      - name: Build refyne-api
        env:
          CGO_ENABLED: 0
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          COMMIT="${{ github.sha }}"
          DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          PKG="github.com/jmylchreest/refyne-api/internal/version"
          go build -ldflags "-s -w -X $PKG.Version=$VERSION -X $PKG.Commit=$COMMIT -X $PKG.Date=$DATE" \
            -o refyne-api ./cmd/refyne-api
        working-directory: api

      - name: Create distribution
        run: |
          mkdir -p dist

          # Standalone binary
          cp api/refyne-api dist/refyne-api-${{ matrix.goos }}-${{ matrix.goarch }}

          # Archive with all files
          tar -czvf dist/refyne-api_${{ needs.prepare.outputs.version }}_${{ matrix.goos }}_${{ matrix.goarch }}.tar.gz \
            -C api refyne-api \
            -C .. LICENSE 2>/dev/null || \
          tar -czvf dist/refyne-api_${{ needs.prepare.outputs.version }}_${{ matrix.goos }}_${{ matrix.goarch }}.tar.gz \
            -C api refyne-api

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: refyne-api_${{ needs.prepare.outputs.version }}_${{ matrix.goos }}_${{ matrix.goarch }}
          path: dist/*
          retention-days: 1

  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [prepare, build-api]
    if: false  # Temporarily disabled during active development
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Linux AMD64 binary
        uses: actions/download-artifact@v4
        with:
          name: refyne-api_${{ needs.prepare.outputs.version }}_linux_amd64
          path: artifacts/linux-amd64

      - name: Download Linux ARM64 binary
        uses: actions/download-artifact@v4
        with:
          name: refyne-api_${{ needs.prepare.outputs.version }}_linux_arm64
          path: artifacts/linux-arm64

      - name: Prepare binaries for Docker
        run: |
          mkdir -p docker-build/linux/amd64 docker-build/linux/arm64
          cp artifacts/linux-amd64/refyne-api-linux-amd64 docker-build/linux/amd64/refyne-api
          cp artifacts/linux-arm64/refyne-api-linux-arm64 docker-build/linux/arm64/refyne-api
          chmod +x docker-build/linux/*/refyne-api

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=ref,event=branch
            type=sha,prefix=

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: api/Dockerfile.ci
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.prepare.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [prepare, build-api, build-docker]
    if: false  # Temporarily disabled during active development
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: false

      - name: Prepare release assets
        run: |
          mkdir -p release

          # Move all build artifacts to release folder
          find artifacts -type f \( -name "*.tar.gz" -o -name "refyne-api-*" \) -exec mv {} release/ \;

          echo "=== Release assets ==="
          ls -la release/

      - name: Generate checksums
        run: |
          cd release
          sha256sum * > checksums.txt
          echo "=== Checksums ==="
          cat checksums.txt

      - name: Generate changelog
        run: |
          if [[ "${{ needs.prepare.outputs.is_release }}" == "true" ]]; then
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              echo "## Changelog" > changelog.txt
              echo "" >> changelog.txt
              git log --pretty=format:"* %h %s" $PREV_TAG..HEAD | \
                grep -v "^* [a-f0-9]* docs:" | \
                grep -v "^* [a-f0-9]* test:" | \
                grep -v "^* [a-f0-9]* ci:" | \
                grep -v "^* [a-f0-9]* Merge" >> changelog.txt || echo "* No notable changes" >> changelog.txt
            else
              echo "* Initial release" > changelog.txt
            fi
          else
            cat > changelog.txt << EOF
          **Automated snapshot build from main branch**

          Version: \`${{ needs.prepare.outputs.version }}\`
          Commit: \`${{ github.sha }}\`

          Docker: \`ghcr.io/${{ github.repository }}:sha-$(echo ${{ github.sha }} | cut -c1-7)\`

          This is an unstable development build. Use at your own risk.
          EOF
          fi
          echo "=== Changelog ==="
          cat changelog.txt

      - name: Create release
        run: |
          if [[ "${{ needs.prepare.outputs.is_release }}" == "true" ]]; then
            gh release create "${{ needs.prepare.outputs.version_tag }}" \
              --title "${{ needs.prepare.outputs.version_tag }}" \
              --notes-file changelog.txt \
              release/*
          else
            gh release create "${{ needs.prepare.outputs.version_tag }}" \
              --title "Snapshot ${{ needs.prepare.outputs.version }}" \
              --prerelease \
              --notes-file changelog.txt \
              release/*
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old snapshot releases
        if: needs.prepare.outputs.is_release != 'true'
        run: |
          RETENTION=${{ env.SNAPSHOT_RETENTION }}
          echo "Keeping ${RETENTION} most recent snapshot releases"

          # List snapshot prereleases, newest first
          SNAPSHOTS=$(gh release list --limit 50 --json tagName,isPrerelease \
            --jq '.[] | select(.isPrerelease) | select(.tagName | test("^v[0-9]+\\.[0-9]+\\.[0-9]+-dev\\.")) | .tagName')

          COUNT=0
          for TAG in $SNAPSHOTS; do
            COUNT=$((COUNT + 1))
            if [ $COUNT -gt $RETENTION ]; then
              echo "Deleting old snapshot release: ${TAG}"
              gh release delete "${TAG}" --yes --cleanup-tag || true
            fi
          done

          echo "Cleanup complete. Kept ${RETENTION} most recent snapshots."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
